# あなたはAIよりうまく偽文書を見分けられるか？API
RESTful APIの基本的なメソッド（GET, POST, PUT/PATCH, DELETE）の実装練習

与えられた職務記述書に対し、AIとユーザーがそれぞれ偽文書かどうか判断する。そして、その精度を競う。
- 対決機能
  - GET: 問題文とIDの取得。
  - POST: ユーザーの回答の送信。
- みんなの戦歴一覧機能
  - GET: 戦歴一覧を取得。
  - PUT/PATCH: 戦歴上のユーザー名の変更。
  - DELETE: 戦歴を削除。

## 導入方法
ターミナルで以下のコードを実行する
1. リポジトリからデータをダウンロード
    ```terminal
    git clone git@github.com:AK-8420/FastAPI-AI_vs_User.git
    ```
2. 仮想環境を有効化

    Windows PowerShellの場合
    ```terminal
    cd FastAPI-AI_vs_User
    .\.venv\Scripts\Activate.ps1
    ```
3. setup.pyで初期設定を実行
    ```
    python setup.py
    ```
4. ローカルサーバーを立てる
    ```python
    python -m uvicorn main:app --reload
    ```
5. [http://128.0.0.1/docs](http://128.0.0.1/)でアクセスポイントの確認

## 構成
- サーバープログラム（python）
  - FastAPI
  - uvicorn
  - SQLite
    - PostgreSQLも候補だったがサーバー複数にする予定はないのでこれで十分
  - SQLAlchemy
    - 接続プール管理をしてくれる
- AI
  - scikit-learn
  - xgboost
    - 学習が早く、精度も良いらしいのでXGBoostを採用
  - データセット: [Real / Fake Job Posting Prediction](https://www.kaggle.com/datasets/shivamb/real-or-fake-fake-jobposting-prediction)

## 1時間でどこまで実装できるかチャレンジ
2023/12/06 21:45からスタート

まずタスクの書き出しを行った (10分)
- setup.pyの作成
  - SQLite DBの作成
  - モデル学習
    - データセットの偽文800個のうち、100個をテストデータ、その他を訓練データとする
    - テストデータのみcsvファイルで保存
- main.pyの作成
  - 対決機能実装
    - 問題文の取得
    - ユーザー回答の送信
    - 結果の返答
  - 戦歴一覧機能実装
    - 現在の戦歴の取得
    - 特定の戦歴の削除
    - 特定の戦歴のユーザー名の修正

ＤＢのテーブル構成を考えた（3分）
- 戦歴テーブル
  - ハッシュID（String）
  - 日時（UNIX時間、Integer）
  - ユーザー名（String）
  - 勝敗（Integer）

SQLiteファイルの作成（9分）

問題文(ダミー)の取得を実装（12分、簡単な動作確認してから実装）

ユーザー回答の送信を実装（16分、クエリの扱いに手間取った）

結果(ダミー)の返答を実装（10分）

2023/12/06 22:45に終了。対決機能の枠組みだけ完成するという結果になった。

![screen shot](images_for_README/ss01.png?raw=true)

## 1時間実装していく中で思ったこと
- ユーザー回答の送信タイミングで回答の正否を評価するか、結果の表示タイミングで評価するか迷った
  - 結果の表示時の方が関数の役割が近くてよさそうとこの時は判断。
- 問題文（テストデータ）が固定なので、AIにはセットアップ時に事前に全問の回答を考えさせた方が処理時間の削減になるだろう
- Ruby on Railsみたいにテストを自動化したい

## 進捗 Part.2
目標：本物の問題文の取得、戦歴のデータベースへの代入

テストコードの追加（test_.py）
- 問題文IDが1～100のとき正常に取得できるか？
- 問題文IDが範囲から外れるとき例外が返るか？
- ユーザー解答がフォーマットにそぐわないとき例外が返るか？
- 結果IDがデータベースに存在するとき戦歴を正常に取得できるか？
- 結果IDがデータベースに存在しないとき例外が返るか？

テーブル構成を変更。戦歴に問題文IDやユーザーの回答を載せることで、後に統計的な分析ができるようにする。
- 問題文IDをカラムに追加
- 勝敗フラグをカラムから削除、ユーザーがどちらを回答したかを代わりに追加
（勝敗は問題文テーブルとユーザー回答の比較で確認できるため）

約2時間でデータセットの分割と、問題文の取得に成功
![screen shot](images_for_README/ss02.png?raw=true)

データベース管理に関して、いくつか仕様変更
- 戦歴削除を特定のユーザーしか行えないように、戦歴IDをIPアドレス等を参照してハッシュ化する計画 ⇒ 単純なUUIDに変更。
  - 他人に分からないならそれで十分なため
- AIによる予測結果を格納するテーブルを新たに作成。問題文IDを外部キーとして戦歴テーブルと紐づける。

PandasでSQLiteデータベースに書き込むという初期案は、複数ユーザーと通信する上で非効率的なのではないかと思ったため、ORMのSQLAlchemyを通じて書き込む仕様に変更した。
[公式チュートリアル](https://fastapi.tiangolo.com/tutorial/sql-databases/)を見ながら実装。

初めて使うので苦戦しつつ、戦歴作成処理に成功！（result_battleの値はまだ適当）
![screen shot](images_for_README/ss03.png?raw=true)
![screen shot](images_for_README/ss04.png?raw=true)

## 試行錯誤ポイント
- 仮想環境フォルダをgitにステージングしたらファイルサイズが大きすぎてpushできなくなった。
  - ステージングする前までcommitを巻き戻して、仮想環境フォルダをgitignoreで除外し解決。
- 問題文のcsvファイルをPandasのDataFrameとして読み込むか、FastAPIのmodelとして保持するか迷った
  - ChatGPTに聞いてみた。
    - 答え：FastAPIのBaseModel使用は、データのバリデーションとシリアライゼーションに重点を置き、型安全性とAPIの自動ドキュメンテーション生成に適しています。
  - 問題文に対してバリデーションを行う予定はなかったので、Pandasで保持することにした。
- 公式チュートリアルではpydantic v1を使用していたが、最新のpydantic v2では仕様がいくつか変わっていたため、コピペだとテスト時にWarningが出た
  - Warning文を見ながらコードを修正して対応した。
- ORM導入時に伴いコードを大幅に書き直した。
  - データベースのセッション設定、AIモデル構築、サーバー開始のタイミングを設計しなおした
  - エンドポイントと渡すデータ型を変更。それに伴いテストコードも書き直し。
    - 問題文IDがユーザーに事前にわかることは無いので、問題文取得にIDがいらない仕様に変更。
  - 作業の結果、問題文を外部出力する必要がなくなった。また、バリデーションの設定の手間も減った。